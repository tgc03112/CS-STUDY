# Database

- [데이터베이스](#데이터베이스)
  - 데이터베이스를 사용하는 이유
  - 데이터베이스 성능
- [Index](#INDEX)
  - Index 란 무엇인가
  - Index 의 자료구조
  - Clustering Index
  - Primary index vs Secondary index
  - Index 의 성능과 고려해야할 사항
- [정규화](#정규화)
  - 정규화 탄생 배경
  - 정규화란 무엇인가
  - 정규화의 종류
  - 정규화의 장단점
- [Transaction](#Transaction)
  - 트랜잭션(Transaction)이란 무엇인가?
  - Commit, Rollback
  - 트랜잭션과 Lock
  - 트랜잭션의 특성
  - 트랜잭션을 사용할 때 주의할 점
- 교착상태
  - 교착상태란 무엇인가
  - 교착상태의 예(MySQL)
  - 교착 상태의 빈도를 낮추는 방법
- Statement vs PreparedStatement
- NoSQL
  - 정의
  - CAP 이론
    - 일관성
    - 가용성
    - 네트워크 분할 허용성
  - 저장방식에 따른 분류
    - Key-Value Model
    - Document Model
    - Column Model



### 데이터베이스

#### 데이터베이스를 사용하는 이유

- 데이터베이스 전에 파일 시스템을 사용했으나 대용량의 데이터를 다루기에 한계점이 있기 때문이다.
- 데이터의 종속성 문제와 무결성 문제가 발생하는 것을 데이터베이스가 해결해준다.

##### 데이터 베이스란

- 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임
  - 실시간 접근성(Real Time Access)
  - 계속적인 변화(Continuous Evolution)
  - 동시 공용(Concurrent Sharing)
  - 내용에 의한 참조(Contents Reference)

##### 데이터 베이스의 특징

1. 데이터의 독립성 
   - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
   - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요 구를 만족시켜줄 수 있다.
2. 데이터의 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
3. 데이터의 보안성
   - 인가된 사용자들만 데이터베이스에 접근할 수 있도록 접근 권한을 설정함으로서 데이터에 보안을 구현한다.
4. 데이터의 일관성
   - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만을 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한, 작업 중 일부 데이터만 변경되는 경우를 막을 수 있다.
5. 데이터 중복 최소화
   - 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 데이터의 중복성 문제를 해결할 수 있다. 

#### 데이터베이스의 성능

데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작된다. 디스크 I/O 란 디스크 드라이브를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동 시킨 다음 데이터를 읽는 것을 의미한다. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.

그러므로 순차 I/O가 랜덤 I/O보다 빠르다. 하지만 현실에서는 대부분이 랜덤 I/O이다. 데이터베이스 쿼리 튜닝은 랜덤 I/O자체를 줄여주는 것이 주 목적이다.



### INDEX

#### Index 란 무엇인가

- RDBMS에서 검색 속도를 높이기 위한 기술
- 데이터베이스 안의 레코드를 처음부터 풀스캔하지 않고, B+ 트리로 구성된 구조에서 인덱스 파일 검색으로 속도를 향상시키는 기술
- 칼럼의 값과 해당 레코드가 저장된 주소를 **키와 값의 쌍으로 인덱스**를 만든다.
- 결론적으로 인덱스는 데이터의 저장 성능을 희생하고 대신 데이터의 읽기 속도(접근 속도)를 높이는 기능이다.

#### Index 의 자료구조

- B+-Tree Index
  - B+-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash Index
  - 컬럼의 값으로 해시 값을 계산해서 인덱싱
- **B+-Tree 를 사용하는 이유**
  - SELECT 질의 조건에는 부등호 연산도 포함
  - **hash table을 사용하게 된다면 등호 연산이 아닌 부등호 연산의 경우 문제가 발생하므로 B+-Tree 사용**

#### Clustering Index : Sparse Index

- Index에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값(물리적으로 인접한 장소에 저장되어있는 데이터)들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다.

- **키가 아닌 필드에 따라 물리적으로 정렬**되어 있으면 **이 키가 아닌 필드를 클러스터링 필드**라고 한다.
- 이 데이터 파일을 클러스터드 파일이라고 한다.
- 클러스터링 인덱스는 클러스터링 필드의 유일한 값마다 하나의 엔트리를 갖는다.
  - 각 엔트리는 값과 포인터를 갖는다.
  - 포인터는 클러스터링 필드에 그 값을 갖는 레코드가 들어있는 첫번째 레코드를 가리킴.

#### Primary Index vs Secondary Index

- 클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용

- **Primary Index**

  - 두 개의 필드로 구성되는 고정 길이 레코드들의 순서 파일

    - 첫 번째 필드 : 데이터 파일의 순서 키 필드(기본키 필드)
    - 두 번째 필드 : 디스크 블록에 대한 포인터

  - 인덱스 파일에는 데이터 파일의 각 블록마다 하나의 인덱스 엔트리가 있다.

    ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6300d005-34fb-401c-97fc-bdb3a360db4f%2FUntitled.png?table=block&id=da8407ec-1ed4-4702-a746-c4ea24c76699&spaceId=934f5057-b12d-47a0-a72c-63ac0dcec742&width=860&userId=8761e111-ea53-40f7-86ae-c95924577431&cache=v2)

  - 각 블록에서 첫 번쨰 레코드를 블록의 앵커 레코드라 한다. (블록 앵커라고도 한다.)

- **Secndary Index(Dense Index)**

  - **기본 접근 방법이 이미 존재하는 데이터 파일을 접근하는 보조 수단을 제공**

  - 후보키나 모든 레코드에 대해 유일한 값을 갖는 필드 또는 중복된 값을 갖는 키가 아닌 필드에 대해 만들 수 있다.

  - 첫 번째 필드 : 인덱스 필드

  - 두 번째 필드 : 블록 포인터이거나 레코드 포인터

  - **같은 파일에 여러 개의 보조 인덱스 생성 가능**

    - 이들 각각은 특정 필드에 대해 이 파일을 접근하는 보조 수단

  - 보조 인덱스에서는 데이터 파일의 각 레코드마다 하나의 인덱스 엔트리가 존재

    ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8352f2b2-e4b9-420b-8626-02bed90c5f68%2FUntitled.png?table=block&id=33cb5b6b-99e4-40ba-ba11-4c32479e304f&spaceId=934f5057-b12d-47a0-a72c-63ac0dcec742&width=1530&userId=8761e111-ea53-40f7-86ae-c95924577431&cache=v2)

#### Index 의 성능과 고려해야할 사항

##### Index 장단점 

- 장점
  - 키 값을 기초로하여 테이블에서 **검색과 정렬 속도 향상**
  - 인덱스를 사용하면 테이블 행의 고유성 강화
  - 테이블의 기본키는 자동으로 인덱스 생성
- 단점
  - 인덱스된 필드에서 **데이터를 업데이트하거나 레코드를 추가 또는 삭제할 때 성능저하**
  - **인덱스를 위한 추가 공간 필요**
  - **데이터 변경 작업이 자주 일어나는 경우 인덱스를 재작성**해야 할 필요가 있기 때문에 성능에 영향을 줄 수 있다



### 정규화

- 데이터베이스에서 **중복을 최소화하기 위해 데이터를 구조화하는 작업**
- **중복을 최소화하고, 삽입/삭제/수정 이상을 최소화**하기 위해 외래키와 기본키를 기반으로 주어진 스키마를 분석하는 과정
- **비정규화**란 더 높은 정규형 릴레이션들을 **조인한 결과를 기본 릴레이션(더 낮은 정규형에 속하는 릴레이션)으로 저장하는 과정**

#### 정규화가 만족해야 하는 조건

- **무손실 조인 특성**은 매우 중요하고, 어떤 일이 있어도 반드시 지켜야 함.

##### 1.Lossless Join Property

- 정규화로 인해 나누어진 2개의 테이블을 합쳤을 때, 원래 가지고 있던 데이터에서 어떠한 데이터 손실도 없어야 한다는 것이다.

##### 2.Functionally Dependency 보존 특성

- 각 FD가 분해 후 생성된 릴레이션의 일부에서는 반드시 표현된다는 특성

#### Functionally Dependency

![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F626825c4-d1f2-427c-9439-44666ac4ad66%2FUntitled.png?table=block&id=4d255ff4-695c-4ee3-a951-96951af1f891&spaceId=934f5057-b12d-47a0-a72c-63ac0dcec742&width=530&userId=8761e111-ea53-40f7-86ae-c95924577431&cache=v2)

- X와 Y를 임의의 애트리뷰트 집합이라고 할 때, X의 값이 Y를 유일하게 결정한다면, `X는 Y를 함수적으로 결정한다.`
- 즉, **임의의 투플의 X 부분의 값이 Y 부분의 값을 고유하게 결정**
- **기본키나 후보키가 아니더라도 Y 값을 유일하게 결정하는 속성 X는 함수 종속 관계에서 모두 결정자가 될 수 있다.**

### 제 1정규형 : 1NF

- **릴레이션에 속한 모든 속성을 도메인의 원자값(atomic value)으로 구성**
- 즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 애트리뷰트 이들의 조합을 허용하지 않는다.

### 제2정규형 : 2NF

- **어떤 릴레이션 R이 제1정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수적 종속인 정규형**
- **부분 함수 종속을 제거하고 모든 속성이 기본키에 완전 함수 종속되도록 릴레이션을 분해**하는 과정을 거쳐야 함.

#### Full Functional Dependency(완전 함수적 종속성)

- **FD X → Y에서 X에 속하는 어떤 애트리뷰트를 제거하면 더이상 함수적 종속성이 성립하지 않는 것을 의미**
- X에 포함된 임의의 애트리뷰트 A(X에 포함)를 X에서 제거하면 Y가 함수적으로 종속하지 않는 경우를 말한다.

#### Partial Functional Dependency(부분 함수적 종속성)

- FD X → Y에서, **X에 포함된 임의의 애트리뷰트 A를 제거해도 X가 Y를 유일하게 결정하는 경우**

### 제 3정규형 : 3NF

- 어떤 릴레이션 R이 제 2정규형에 있으며, **기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속성이 아닌 상태**

#### 이행적 종속성(Transitive Dependency)

- 릴레이션에서 **키가 아닌 애트리뷰트들이 키가 아닌 애트리뷰트에 함수적으로 종속하는 경우**
- 즉, 키가 아닌 애트리뷰트들이 PK에 이행적으로 종속해서는 안 된다.

### BCNF : 보이스코드 정규형

- 릴레이션 R의 **모든 결정자 후보키**이면 릴레이션 R은 보이스 코드 정규형에 속하는 상태
- **FD X → A를 만족할 때마다, X는 R의 후보키라면 릴레이션 R은 BCNF**

#### 정규화 장점 & 단점

- 장점 : **데이터베이스 변경 시 이상 현상 제거**
- 단점 : 릴레이션의 분해로 인해 **릴레이션 간의 JOIN 연산이 많아진다**.

#### 반정규화 대상

- 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많은, 항상 일정한 범위만을 조회하는 경우
- 테이블에 **지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 매우 어려운 경우**

### 정규화 과정 정리

- **1NF** : 릴레이션에 속하는 **모든 속성의 도메인이 원자 값**으로 구성되어 있음.
- **2NF** : **릴레이션이 1NF**에 속하고, **기본키가 아닌 모든 속성이 기본키에 완전 함수 종속**되어 있음.
- **3NF** : **릴레이션이** **2NF**에 속하고, **기본키가 아닌 모든 속성이 기본키에** **이행적으로 함수 종속되지 않음.**
- **BCNF** : 릴레이션의 함수 종속 관계에서 **모든 결정자가 후보키**



### Transaction

#### 트랜잭션(Transaction)이란 무엇인가?

- 트랙잭션은 작업의 완전성을 보장해 주는 것. 
- 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에 원 상태로 복구해서 작업의 일부만 적용되어 남아있는 현상이 발생하지 않게 만들어 주는 기능
- **정확성을 보장하기 위해 완전히 종료해야 하는 데이터베이스 처리의 논리적 단위를 표현**
- 상태를 변화시킨다는 것은 SQL 질의어를 통해 DB에 접근한 느것.
- 즉, 하나의 트랙잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져다 준다.
- **트랙잰션은 DB에 장애가 발생했을 때 데이터를 복구하는 작업의 단위**도 된다.

#### Commit, Rollback

![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa07e3ea4-67a8-4d7f-b314-91f2c37c39f6%2FUntitled.png?table=block&id=bda61d21-72b6-4837-a4aa-064eca9c6846&spaceId=934f5057-b12d-47a0-a72c-63ac0dcec742&width=910&userId=8761e111-ea53-40f7-86ae-c95924577431&cache=v2)

- **Commit**
  - 한 개의 트랙잭션에 대한 작업이 성공적으로 끝나 데이터베이스가 일관된 상태일 때 , 갱신이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
  - **해당 트랙잭션의 갱신 결과가 데이터베이스에 영구적으로 기록**
- **Rollback**
  - 하나의 트랙잭션 처리가 **비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때** 트랙잭션의 **원자성(Atomicity)을 구현하기 위해 이 트랙잭션이 행한 모든 연산을 취소(Undo)하는 연산**
  - Rollback 시에는 해당 트랙잭션을 재시작하거나 폐기

#### 트랜잭션과 Lock

- 잠금(Lock)과 트랙잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능.
- 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. (여기서 자원은 레코드나 테이블을 말한다.)
- 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다. 트랜잭션은 하나의 논리적 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100%적용 되거나 아무것도 적용되지 않아야 함을 보장하는 것이다.

#### 트랜잭션의 특성

- ##### **트랜잭션 ACID** **: 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질**

1. **원자성(Atomicity)**
   - 트랜잭션이 DB에 모두 반영되거나 혹은 전혀 반영되지 않아야 한다. -> All-or-Nothing
   - 아무 문제가 발생되지 않았을 경우에만 작업이 수행되어야 한다.
2. **일관성(Consistency)**
   - 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
3. **고립성(Isolation)**
   - 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행된다.
   - 다수의 트랜잭션이 동시에 수행중인 상황에서 하나의 트랜잭션이 완료될 때 까지는 현재 실행중인 트랜잭션의 중간 수행 결과를 다른 트랜잭션에서 보거나 참조할 수 없다.
4. **지속성(Durability)**
   - 트랜잭션이 정상적으로 완료되면 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

- #### 트랜잭션의 상태

  ![트랜잭션 상태 다이어그램](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/transaction-status.png)

  - Active : 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.

  - Failed : 트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.

  - Partially Commited : 트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 Commit 이전 sql문이 수행되고 Commit 만 남은 상태를 말한다.

  - Committed : 트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.

  - Aborted : 트랜잭션 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.

    

#### 트랜잭션을 사용할 때 주의할 점

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉, 트랜잭션의 범위를 최소화 하라는 의미이다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생 할 수 도 있다.









