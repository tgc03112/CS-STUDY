# Database

- [데이터베이스](#데이터베이스)
  - 데이터베이스를 사용하는 이유
  - 데이터베이스 성능
- [Index](#INDEX)
  - Index 란 무엇인가
  - Index 의 자료구조
  - Clustering Index
  - Primary index vs Secondary index
  - Index 의 성능과 고려해야할 사항
- 정규화에 대해서
  - 정규화 탄생 배경
  - 정규화란 무엇인가
  - 정규화의 종류
  - 정규화의 장단점
- Transaction
  - 트랜잭션(Transaction)이란 무엇인가?
  - 트랜잭션과 Lock
  - 트랜잭션의 특성
  - 트랜잭션을 사용할 때 주의할 점
- 교착상태
  - 교착상태란 무엇인가
  - 교착상태의 예(MySQL)
  - 교착 상태의 빈도를 낮추는 방법
- Statement vs PreparedStatement
- NoSQL
  - 정의
  - CAP 이론
    - 일관성
    - 가용성
    - 네트워크 분할 허용성
  - 저장방식에 따른 분류
    - Key-Value Model
    - Document Model
    - Column Model



### 데이터베이스

#### 데이터베이스를 사용하는 이유

- 데이터베이스 전에 파일 시스템을 사용했으나 대용량의 데이터를 다루기에 한계점이 있기 때문이다.
- 데이터의 종속성 문제와 무결성 문제가 발생하는 것을 데이터베이스가 해결해준다.

##### 데이터 베이스란

- 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임
  - 실시간 접근성(Real Time Access)
  - 계속적인 변화(Continuous Evolution)
  - 동시 공용(Concurrent Sharing)
  - 내용에 의한 참조(Contents Reference)

##### 데이터 베이스의 특징

1. 데이터의 독립성 
   - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
   - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요 구를 만족시켜줄 수 있다.
2. 데이터의 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
3. 데이터의 보안성
   - 인가된 사용자들만 데이터베이스에 접근할 수 있도록 접근 권한을 설정함으로서 데이터에 보안을 구현한다.
4. 데이터의 일관성
   - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만을 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한, 작업 중 일부 데이터만 변경되는 경우를 막을 수 있다.
5. 데이터 중복 최소화
   - 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 데이터의 중복성 문제를 해결할 수 있다. 

#### 데이터베이스의 성능

데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작된다. 디스크 I/O 란 디스크 드라이브를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동 시킨 다음 데이터를 읽는 것을 의미한다. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.

그러므로 순차 I/O가 랜덤 I/O보다 빠르다. 하지만 현실에서는 대부분이 랜덤 I/O이다. 데이터베이스 쿼리 튜닝은 랜덤 I/O자체를 줄여주는 것이 주 목적이다.



### INDEX

#### Index 란 무엇인가

- RDBMS에서 검색 속도를 높이기 위한 기술
- 데이터베이스 안의 레코드를 처음부터 풀스캔하지 않고, B+ 트리로 구성된 구조에서 인덱스 파일 검색으로 속도를 향상시키는 기술
- 칼럼의 값과 해당 레코드가 저장된 주소를 **키와 값의 쌍으로 인덱스**를 만든다.
- 결론적으로 인덱스는 데이터의 저장 성능을 희생하고 대신 데이터의 읽기 속도(접근 속도)를 높이는 기능이다.

#### Index 의 자료구조

- B+-Tree Index
  - B+-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash Index
  - 컬럼의 값으로 해시 값을 계산해서 인덱싱
- **B+-Tree 를 사용하는 이유**
  - SELECT 질의 조건에는 부등호 연산도 포함
  - **hash table을 사용하게 된다면 등호 연산이 아닌 부등호 연산의 경우 문제가 발생하므로 B+-Tree 사용**

#### Clustering Index : Sparse Index

- Index에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값(물리적으로 인접한 장소에 저장되어있는 데이터)들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다.

- **키가 아닌 필드에 따라 물리적으로 정렬**되어 있으면 **이 키가 아닌 필드를 클러스터링 필드**라고 한다.
- 이 데이터 파일을 클러스터드 파일이라고 한다.
- 클러스터링 인덱스는 클러스터링 필드의 유일한 값마다 하나의 엔트리를 갖는다.
  - 각 엔트리는 값과 포인터를 갖는다.
  - 포인터는 클러스터링 필드에 그 값을 갖는 레코드가 들어있는 첫번째 레코드를 가리킴.

#### Primary Index vs Secondary Index

- 클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용

- **Primary Index**

  - 두 개의 필드로 구성되는 고정 길이 레코드들의 순서 파일

    - 첫 번째 필드 : 데이터 파일의 순서 키 필드(기본키 필드)
    - 두 번째 필드 : 디스크 블록에 대한 포인터

  - 인덱스 파일에는 데이터 파일의 각 블록마다 하나의 인덱스 엔트리가 있다.

    ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6300d005-34fb-401c-97fc-bdb3a360db4f%2FUntitled.png?table=block&id=da8407ec-1ed4-4702-a746-c4ea24c76699&spaceId=934f5057-b12d-47a0-a72c-63ac0dcec742&width=860&userId=8761e111-ea53-40f7-86ae-c95924577431&cache=v2)

  - 각 블록에서 첫 번쨰 레코드를 블록의 앵커 레코드라 한다. (블록 앵커라고도 한다.)

- **Secndary Index(Dense Index)**

  - **기본 접근 방법이 이미 존재하는 데이터 파일을 접근하는 보조 수단을 제공**

  - 후보키나 모든 레코드에 대해 유일한 값을 갖는 필드 또는 중복된 값을 갖는 키가 아닌 필드에 대해 만들 수 있다.

  - 첫 번째 필드 : 인덱스 필드

  - 두 번째 필드 : 블록 포인터이거나 레코드 포인터

  - **같은 파일에 여러 개의 보조 인덱스 생성 가능**

    - 이들 각각은 특정 필드에 대해 이 파일을 접근하는 보조 수단

  - 보조 인덱스에서는 데이터 파일의 각 레코드마다 하나의 인덱스 엔트리가 존재

    ![img](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8352f2b2-e4b9-420b-8626-02bed90c5f68%2FUntitled.png?table=block&id=33cb5b6b-99e4-40ba-ba11-4c32479e304f&spaceId=934f5057-b12d-47a0-a72c-63ac0dcec742&width=1530&userId=8761e111-ea53-40f7-86ae-c95924577431&cache=v2)

#### Index 의 성능과 고려해야할 사항

##### Index 장단점 

- 장점
  - 키 값을 기초로하여 테이블에서 **검색과 정렬 속도 향상**
  - 인덱스를 사용하면 테이블 행의 고유성 강화
  - 테이블의 기본키는 자동으로 인덱스 생성
- 단점
  - 인덱스된 필드에서 **데이터를 업데이트하거나 레코드를 추가 또는 삭제할 때 성능저하**
  - **인덱스를 위한 추가 공간 필요**
  - **데이터 변경 작업이 자주 일어나는 경우 인덱스를 재작성**해야 할 필요가 있기 때문에 성능에 영향을 줄 수 있다



















